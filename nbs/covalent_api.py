# AUTOGENERATED! DO NOT EDIT! File to edit: covalent_api.ipynb.

# %% auto 0
__all__ = ['logger', 'url_decorator', 'Covalent_Api', 'union_top_n', 'intersection_count', 'contract_name_if_k_holders',
           'contract_name_if_more_than_k_holders', 'contract_address_to_holders', 'Address_Holder_Data']

# %% covalent_api.ipynb 4
import json
import requests
from requests.auth import HTTPBasicAuth
from requests.exceptions import HTTPError, RequestException
import time
from fastcore.basics import *

# %% covalent_api.ipynb 6
import logging

# Set up basic logging configuration
logging.basicConfig(level=logging.WARNING, format='%(message)s')

logger = logging.getLogger(__name__)

# %% covalent_api.ipynb 7
#The general API is: 
#                       def some_function(self,args):
#                            url = ... #define the url using args
#                            return self.get_items(url)

#rather than writing self.get_items(url) every time, we can use a decorator to do this for us.

def url_decorator(func):
    def wrapper(self, *args, **kwargs):
        url = func(self, *args, **kwargs)
        return self.get_items(url)
    return wrapper

class Covalent_Api:
    """This class is used to interact with the Covalent API.
    """

    def __init__(self, api_key='cqt_rQ37X8PXHqGxkycgdXHJtkFhfwyP'):
        self.api_key = api_key


    def get_items(self, url, retries=3, delay=1):
        """Given a url, get the items from the API.
        Inputs:
            `url`, a string, the url to get the items from.
            `retries`, an integer, the number of times to retry the request.
            `delay`, an integer, the number of seconds to wait between retries.

        Outputs:
            `items`, a list of dictionaries, each dictionary containing information about a token/address/etc
        """
        headers = {"accept": "application/json"}
        basic = HTTPBasicAuth(f'{self.api_key}', '')

        #TODO: e.g. if it is a mevbot with heaps of transactions this might fail: perhaps needs a timer.
        while retries > 0:
            try:
                response = requests.get(url, headers=headers, auth=basic)
                response.raise_for_status()  # Check for HTTP errors
                data = response.json()

                # Access 'data' field
                data = data.get('data')
                if data is None:
                    return None

                # Check if data is a list
                if type(data) is list:
                    return data

                # Access 'items' field
                return data.get('items')
            
            except HTTPError as e:
                if e.response.status_code == 429:  # HTTP Status Code for 'Too Many Requests'
                    time.sleep(delay)  # Adjust wait time
                    retries -= 1
                else:
                    return None

            except RequestException as e:
                return None


    @url_decorator
    def get_historical_balances(self,chainName:str,walletAddress:str,date:str, quote_currency="USD")->list:
        """
            API docs: https://www.covalenthq.com/docs/api/balances/get-historical-token-balances-for-address/
            Given a wallet address, get the historical balances for that wallet address on the specified chain and date.
            Inputs:
                `chainName`, e.g. 'eth-mainnet'
                `walletAddress`, e.g. '0x7364a0f792e073814B426c918bf72792575b6c18'
                `date`, e.g. '2021-01-01'.
                `quote_currency`, e.g. 'USD'
            Outputs:
                `items`, a list of dictionaries, each dictionary containing the balance of a token at a given date along with some additional metadata.
            Note:
                While the core function generates a URL, the applied @url_decorator 
                modifies the return behavior to fetch items using that URL.
        """
        assert type(date) is str, "date must be a string"

        url = f"https://api.covalenthq.com/v1/{chainName}/address/{walletAddress}/historical_balances/?quote-currency={quote_currency}&date={date}"

        return url 
    
    @staticmethod
    def print_balance(items):
        "Helper function to print the balance out, i.e. the object returned by `get_historical_balances`"

        for item in items:
            print(f"{item['contract_name']} balance: {item['balance']}\n")
    
    @url_decorator
    def get_token_holders(self, chainName: str, tokenAddress: str, block_height=None, page_size=100, page_number=None) -> list:
        """
        API docs: https://www.covalenthq.com/docs/api/balances/get-token-holders-as-of-any-block-height-v2/
        Fetches the token holders for a specific token on a given chain.
        Note: There is a possible `block-height` parameter, which we omit for now (see the API docs to clarify)
        
        Inputs:
            `chainName`: The chain name e.g. 'eth-mainnet'.
            `tokenAddress`: The token's address.
            `block_height`: Ending block to define a block range.
            `page_size`: Number of items per page. Supported values are 100 and 1000.
            `page_number`: 0-indexed page number to begin pagination.
        Outputs:
            `items`, a list of dictionaries, each dictionary containing information about a token holder.

        Note: This gets the holders by percentage (i.e. largest holdest to smallest)

        Note:
        While the core function generates a URL, the applied @url_decorator 
        modifies the return behavior to fetch items using that URL.
        """

        base_url = f"https://api.covalenthq.com/v1/{chainName}/tokens/{tokenAddress}/token_holders_v2/?"

        url = "https://api.covalenthq.com/v1/eth-mainnet/tokens/{tokenAddress}/token_holders_v2/?"

        
        if block_height is not None:
            base_url += f"&block-height={block_height}"
        if page_size is not None:
            base_url += f"&page-size={page_size}"
        if page_number is not None:
            base_url += f"&page-number={page_number}"

        return base_url

    def get_holders_portfolios(self,n_lst,chainName:str,date:str,quote_currency="USD",log_output=False):
        """Input: 
                `n_lst`: a list of dictionaries containing the top holders of a token. Dictionary must contain the key 'address'.
                 See get_historical_balances for description of other inputs.
           Output: the same list of dictionaries with the portfolio added.
        """

        # Setting up logging level based on the log_output value
        if log_output:
            logger.setLevel(logging.INFO)
        else:
            logger.setLevel(logging.WARNING)

        #loop over the list of dictionaries (holders of the token)
        for _holder in n_lst: #this loop should be parallelized, but ok for now provided it isn't too big.

            _address = _holder['address']
            _items = self.get_historical_balances(chainName=chainName,walletAddress=_address, quote_currency=quote_currency, date=date)
            #_items is a list of dictionaries

            #get the sum of the portfolio

            #TODO: Make this more efficient: possibly convert to numpy array or dataframe or something and then sum
            none_to_zero = lambda x: 0 if x is None else x
            portfolio_sum = sum([none_to_zero(holding['quote']) for holding in _items])
            
            _holder['portfolio']=_items #update the _holder with the whole portfolio
            _holder['portfolio_sum']=portfolio_sum #update the _holder with the total value of the portfolio

            logger.info(f'got {_address} portfolio')  # Logging statement in place of print
            
        return n_lst
    
    #It seems that we already have this data via `get_historical_balances` throughts ['items']['quote'] #usd value
    # @url_decorator
    # def get_prices(self,chainName:str,address:str,quote_currency="USD",dates=None):
    #     """Input: 
    #             `chainName`: e.g. 'eth-mainnet'
    #             `address`: e.g. '0x7364a0f792e073814B426c918bf72792575b6c18'
    #             `quote_currency`: e.g. 'USD'
    #             `dates`: e.g. ['2021-01-01','2021-01-10'], i.e. from,to
    #        Output: 
    #     """

    #     if len(dates)==1:
    #         dates.append(dates[0]) #if only one date is specified, then we get the price for that date only.

    #     url = f"https://api.covalenthq.com/v1/pricing/historical_by_addresses_v2/{chainName}/{quote_currency}/{address}/?from={dates[0]}&to={dates[1]}"
    #     return url
    
    @staticmethod
    def print_prices(items):
        "Helper function to print the prices out i.e. `items` as returned by `get_prices`"
        print(f"Printing out prices of: {items[0]['contract_name']}")
        for k in items[0]['prices']:
            print(f"On {k['date']}, the price was {k['price']}, and the `pretty_price` was {k['pretty_price']}")
            


# %% covalent_api.ipynb 18
def union_top_n(top_n:list)->list:
    """Computes all the coins in the top n portfolios of a token (i.e. union of all portfolios)    
    """

    top_n = list(set(
        (item['contract_name'],item['contract_address'])
        for entry in top_n #Basically: for each address in top_10_nickcage get all the tokens in their portfolio
        for item in entry['portfolio']
                    ))
    return top_n

# %% covalent_api.ipynb 21
def intersection_count(top_n:list, union_lst:list) -> dict:
    """
    For each token in the union, count how many holders have that token in their portfolio.
    Inputs:
        top_n: list of dictionaries, each dictionary is a holder
        union_lst: list of tokens, each token is a string
    Output:
        intersect_dict: dictionary, keys are tokens, values are integers
    """

    # Create a dictionary with default value as 0
    intersect_dict = {(token_name, token_address): 0 for token_name, token_address in union_lst}

    # Pre-compute contract addresses for each holder
    holder_portfolios = {}
    for holder in top_n:
        holder_portfolios[holder['address']] = set(item['contract_address'] for item in holder['portfolio'])

    # Update the intersection count
    for token_name, token_address in union_lst:
        for holder_address, contracts in holder_portfolios.items():
            if token_address in contracts:
                intersect_dict[(token_name, token_address)] += 1

    return intersect_dict



# %% covalent_api.ipynb 26
def contract_name_if_k_holders(intersect_dict,k):
    "Get the contracts that have exactly k holders"
    if k>len(intersect_dict):
        raise ValueError("k is greater than length of intersect_dict")
    return [contract_name for contract_name in intersect_dict.keys() if intersect_dict[contract_name] == k]

def contract_name_if_more_than_k_holders(intersect_dict,k):
    "Get the contracts that have more than k holders"
    if k>len(intersect_dict):
        raise ValueError("k is greater than length of intersect_dict")
    return [contract_name for contract_name in intersect_dict.keys() if intersect_dict[contract_name] > k]

# %% covalent_api.ipynb 29
def contract_address_to_holders(n_holders,contract_address):
    "Given an address, get the holders that hold that address"
    lst=[]
    for _holder in n_holders:
        for _token in _holder['portfolio']:
            if _token['contract_address'] == contract_address:
                lst.append(_holder)

    return lst

# %% covalent_api.ipynb 33
class Address_Holder_Data:

    def __init__(self, cov_api, tokenAddress, chainName,date,n,quote_currency="USD"): 
        store_attr()
        assert n <= 100, f"The value of n should be <= 100. The current value is {n}."
        
        self.intersect_dict_top_n = self.get_data()
        
    def get_data(self):
        self.token_holders = self.cov_api.get_token_holders(chainName=self.chainName, tokenAddress=self.tokenAddress, page_size=100, page_number=0)
        self.top_n_holders = [self.token_holders[i] for i in range(self.n)]
        self.top_n_holders = self.cov_api.get_holders_portfolios(n_lst=self.top_n_holders,chainName=self.chainName,quote_currency=self.quote_currency,date=self.date)
        self.union_top_n = union_top_n(self.top_n_holders)
        self.intersect_dict_top_n = intersection_count(top_n=self.top_n_holders, union_lst=self.union_top_n)

        return self.intersect_dict_top_n

