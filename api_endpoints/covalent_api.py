# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/covalent_api.ipynb.

# %% auto 0
__all__ = ['logger', 'MORALIS_API_KEY', 'ETHERSCAN_API_KEY', 'COVALENT_API_KEY', 'url_decorator', 'Covalent_Api',
           'Union_Portfolios', 'intersection_count', 'contract_name_if_k_holders',
           'contract_name_if_more_than_k_holders', 'holders_more_than_k_addresses', 'strip_none', 'strip_dust',
           'WalletListToIntersectDict', 'AddressTopnToIntersectDict', 'print_tokens_in_portfolios',
           'portfolio_to_pie_chart', 'print_portfolios_more_than_k']

# %% ../nbs/covalent_api.ipynb 5
import json
import requests
from requests.auth import HTTPBasicAuth
from requests.exceptions import HTTPError, RequestException
import time
from fastcore.basics import *
from fastcore.test import *
from typing import List
from prettytable import PrettyTable
import matplotlib.pyplot as plt
from .moralis_api import *

# %% ../nbs/covalent_api.ipynb 6
import logging

# Set up basic logging configuration
logging.basicConfig(level=logging.INFO, format='%(message)s')

logger = logging.getLogger(__name__)

# %% ../nbs/covalent_api.ipynb 7
import os
from dotenv import load_dotenv

load_dotenv()

MORALIS_API_KEY = os.environ.get('moralis_api_key')
ETHERSCAN_API_KEY = os.environ.get('etherscan_api_key')
COVALENT_API_KEY = os.environ.get('covalent_api_key')

# %% ../nbs/covalent_api.ipynb 8
#The general API is: 
#                       def some_function(self,args):
#                            url = ... #define the url using args
#                            return self.get_items(url)

#rather than writing self.get_items(url) every time, we can use a decorator to do this for us.
from requests.exceptions import HTTPError, ReadTimeout, RequestException

def url_decorator(func):
    def wrapper(self, *args, **kwargs):
        url = func(self, *args, **kwargs)
        return self.get_items(url)
        #return self.get_items_with_timeout(url)
    return wrapper

class Covalent_Api:
    """This class is used to interact with the Covalent API.
    """

    def __init__(self, covalent_api_key=COVALENT_API_KEY,etherscan_api_key=ETHERSCAN_API_KEY,moralis_api_key=MORALIS_API_KEY,
                 request_timeout=30,retries=5,delay=1
                 ):
        self.covalent_api_key = covalent_api_key
        self.etherscan_api_key = etherscan_api_key
        self.moralis_api_key = moralis_api_key
        self.request_timeout = request_timeout
        self.retries = retries
        self.delay = delay
        self.price_fetcher = PriceFetcher(self.etherscan_api_key, self.moralis_api_key)


    def get_items(self, url):
        """Given a url, get the items from the API."""

        headers = {"accept": "application/json"}
        basic = HTTPBasicAuth(f'{self.covalent_api_key}', '')

        while self.retries > 0:
            try:
                response = requests.get(url, headers=headers, auth=basic, timeout=self.request_timeout)
                response.raise_for_status()  
                data = response.json()['data']  # Directly access 'data' field
                
                if data is None:
                    logger.warning(f"No data received from {url}. Retries left: {self.retries}")
                    self.retries -= 1
                    time.sleep(self.delay)
                    continue

                if isinstance(data, list):
                    return data

                return data.get('items')

            except (ReadTimeout, RequestException, HTTPError) as e:
                logger.warning(f"{type(e).__name__} occurred: {e} for URL: {url}. Retrying in {self.delay} seconds...")
                self.retries -= 1
                time.sleep(self.delay)
                continue
            except Exception as e:
                logger.error(f"Unexpected error: {e} for URL: {url}. Returning None.")
                return None

        logger.warning(f"Exceeded the maximum number of retries ({self.retries}) for URL: {url} without success")
        return None

    #original. 
    # @url_decorator
    # def get_historical_balances(self,chainName:str,walletAddress:str,date:str, quote_currency="USD")->list:
    #     """
    #         API docs: https://www.covalenthq.com/docs/api/balances/get-historical-token-balances-for-address/
    #         Given a wallet address, get the historical balances for that wallet address on the specified chain and date.
    #         Inputs:
    #             `chainName`, e.g. 'eth-mainnet'
    #             `walletAddress`, e.g. '0x7364a0f792e073814B426c918bf72792575b6c18'
    #             `date`, e.g. '2021-01-01'.
    #             `quote_currency`, e.g. 'USD'
    #         Outputs:
    #             `items`, a list of dictionaries, each dictionary containing the balance of a token at a given date along with some additional metadata.
    #         Note:
    #             While the core function generates a URL, the applied @url_decorator 
    #             modifies the return behavior to fetch items using that URL.
    #     """
    #     assert type(date) is str, "date must be a string"

    #     url = f"https://api.covalenthq.com/v1/{chainName}/address/{walletAddress}/historical_balances/?quote-currency={quote_currency}&date={date}"

    #     return url 

    @url_decorator
    def _fetch_historical_balances(self, chainName: str, walletAddress: str, date: str, quote_currency="USD") -> str:
        """
        This is an internal method that just constructs and returns the URL.
        """
        assert type(date) is str, "date must be a string"
        url = f"https://api.covalenthq.com/v1/{chainName}/address/{walletAddress}/historical_balances/?quote-currency={quote_currency}&date={date}"
        return url 

    def get_historical_balances(self, chainName: str, walletAddress: str, date: str, quote_currency="USD") -> list:
        """
        Given a wallet address, get the historical balances for that wallet address on the specified chain and date.
        This method fetches the data and then processes it.
        """
        items = self._fetch_historical_balances(chainName, walletAddress, date, quote_currency)
        if items is None:
            logger.error(f"Failed to fetch data for {walletAddress} on date {date}")
            return []
        
        for i,token_data in enumerate(items):
            # if self.moralis_skip:
            #     break
    

            if token_data['balance'] in [None, "0"]:
                #print(f"Skipping: {token_data['contract_name']} has no balance or balance is 0.0")
                continue

            if token_data['quote_rate'] is None:
                if token_data['contract_decimals'] is None:
                    #print(f"Token {token_data['contract_name']} has no decimals. Skipping...")
                    continue
                # Fetch the USD price for the token on the desired_date
                assert chainName == 'eth-mainnet', "Only eth-mainnet is supported for now for `get_token_price_on_date`"
                #token_price = moralis_api.get_token_price_on_date(date, token_data['contract_address'],etherscan_api_key, moralis_api_key)                
                token_price = self.price_fetcher.get_token_price_on_date(date, token_data['contract_address'],self.etherscan_api_key, self.moralis_api_key)
                token_data['quote_rate'] = token_price
                if None in [token_data.get('balance'), token_data.get('contract_decimals'), token_price]:
                    token_data['quote'] = None
                else:
                    token_data['quote'] = (float(token_data['balance']) / (10 ** token_data['contract_decimals'])) * token_price

                #token_data['quote'] = (float(token_data['balance']) / (10 ** token_data['contract_decimals'])) * token_price

        #self.price_fetcher.save_cache() #i think this line is redunant now. 

        return items
    
    @staticmethod
    def print_balance(items):
        "Helper function to print the balance out, i.e. the object returned by `get_historical_balances`"

        for item in items:
            print(f"{item['contract_name']} balance: {item['balance']}\n")
    
    @url_decorator
    def get_token_holders(self, chainName: str, tokenAddress: str, block_height=None, page_size=100, page_number=None) -> list:
        """
        API docs: https://www.covalenthq.com/docs/api/balances/get-token-holders-as-of-any-block-height-v2/
        Fetches the token holders for a specific token on a given chain.
        Note: There is a possible `block-height` parameter, which we omit for now (see the API docs to clarify)
        
        Inputs:
            `chainName`: The chain name e.g. 'eth-mainnet'.
            `tokenAddress`: The token's address.
            `block_height`: Ending block to define a block range.
            `page_size`: Number of items per page. Supported values are 100 and 1000.
            `page_number`: 0-indexed page number to begin pagination.
        Outputs:
            `items`, a list of dictionaries, each dictionary containing information about a token holder.

        Note: This gets the holders by percentage (i.e. largest holdest to smallest)

        Note:
        While the core function generates a URL, the applied @url_decorator 
        modifies the return behavior to fetch items using that URL.
        """

        base_url = f"https://api.covalenthq.com/v1/{chainName}/tokens/{tokenAddress}/token_holders_v2/?"

        
        if block_height is not None:
            base_url += f"&block-height={block_height}"
        if page_size is not None:
            base_url += f"&page-size={page_size}"
        if page_number is not None:
            base_url += f"&page-number={page_number}"

        return base_url

    def get_holders_portfolios(self,wallet_list:List[dict],chainName:str,date:str,quote_currency="USD",log_output=False):
        """Input: 
                `wallet_list`: a list of  wallets as dicts. Each dict must contain the key 'address'.
                 See get_historical_balances for description of other inputs.
           Output: the same list of dictionaries with the portfolio added.
        """

        #TODO: this address 0x80f8c8d0d29c99b7af1b4d97cad357061037ecb3 seems to give false data (~$20m for ShibaDoge
        #Maybe should email covalent about this to let them know. Please see the dextools chart for shibadoge. 
        #We plonked the info manually into the covalent API to verify and it looks like it is an issue on their end.
        #Just something to be aware of: covalent seems to not be infallible.

        # Setting up logging level based on the log_output value
        if log_output:
            logger.setLevel(logging.INFO)
        else:
            logger.setLevel(logging.WARNING)

        #loop over the list of dictionaries (holders of the token)
        for _holder in wallet_list: #this loop should be parallelized, but ok for now provided it isn't too big.

            _address = _holder['address']
            logger.info(f'getting {_address} portfolio')  # Logging statement in place of print
            _items = self.get_historical_balances(chainName=chainName,walletAddress=_address, quote_currency=quote_currency, date=date)
            if _items == None:
                print(f'failed to get {_address} portfolio: `get_historical_balances` returned `None`')  # Logging statement in place of print
                _holder['portfolio']=None
                _holder['portfolio_sum']=None
                continue
            
            #_items is a list of dictionaries

            #get the sum of the portfolio

            #TODO: Make this more efficient: possibly convert to numpy array or dataframe or something and then sum
            
            none_to_zero = lambda x: 0 if x is None else x
            portfolio_sum = sum([none_to_zero(holding['quote']) for holding in _items])
            
            _holder['portfolio']=_items #update the _holder with the whole portfolio
            _holder['portfolio_sum']=portfolio_sum #update the _holder with the total value of the portfolio

            logger.info(f'got {_address} portfolio')  # Logging statement in place of print
            
        return wallet_list
    
    #It seems that we already have this data via `get_historical_balances` throughts ['items']['quote'] #usd value
    # @url_decorator
    # def get_prices(self,chainName:str,address:str,quote_currency="USD",dates=None):
    #     """Input: 
    #             `chainName`: e.g. 'eth-mainnet'
    #             `address`: e.g. '0x7364a0f792e073814B426c918bf72792575b6c18'
    #             `quote_currency`: e.g. 'USD'
    #             `dates`: e.g. ['2021-01-01','2021-01-10'], i.e. from,to
    #        Output: 
    #     """

    #     if len(dates)==1:
    #         dates.append(dates[0]) #if only one date is specified, then we get the price for that date only.

    #     url = f"https://api.covalenthq.com/v1/pricing/historical_by_addresses_v2/{chainName}/{quote_currency}/{address}/?from={dates[0]}&to={dates[1]}"
    #     return url
    
    @staticmethod
    def print_prices(items):
        "Helper function to print the prices out i.e. `items` as returned by `get_prices`"
        print(f"Printing out prices of: {items[0]['contract_name']}")
        for k in items[0]['prices']:
            print(f"On {k['date']}, the price was {k['price']}, and the `pretty_price` was {k['pretty_price']}")
            


# %% ../nbs/covalent_api.ipynb 19
def Union_Portfolios(wallet_list:list[dict])->list:
    """Computes all the coins in `wallet_list` (i.e. union of all portfolios)    
    """
    union_portfolios = list(set(
        (item['contract_name'],item['contract_address'])
        for _portfolio in wallet_list #Basically: for each address in top_10_nickcage get all the tokens in their portfolio
        for item in _portfolio['portfolio']
                    ))
    return union_portfolios

# %% ../nbs/covalent_api.ipynb 22
def intersection_count(wallet_list:list, union_lst:list) -> dict:
    """
    For each token in the union, count how many holders have that token in their portfolio.
    Inputs:
        wallet_list: list of dictionaries, each dictionary is a holder
        union_lst: list of tokens, each token is a string
    Output:
        intersect_dict: dictionary, keys are tokens, values are integers
    """

    # Create a dictionary with default value as 0
    intersect_dict = {(token_name, token_address): 0 for token_name, token_address in union_lst}

    # Pre-compute contract addresses for each holder
    holder_portfolios = {}
    for holder in wallet_list:
        holder_portfolios[holder['address']] = set(item['contract_address'] for item in holder['portfolio'])

    # Update the intersection count
    for token_name, token_address in union_lst:
        for holder_address, contracts in holder_portfolios.items():
            if token_address in contracts:
                intersect_dict[(token_name, token_address)] += 1

    return intersect_dict



# %% ../nbs/covalent_api.ipynb 27
def contract_name_if_k_holders(intersect_dict,k):
    "Get the contracts that have exactly k holders"
    if k>len(intersect_dict):
        raise ValueError("k is greater than length of intersect_dict")
    return [contract_name for contract_name in intersect_dict.keys() if intersect_dict[contract_name] == k]

def contract_name_if_more_than_k_holders(intersect_dict,k):
    "Get the contracts that have more than k holders"
    if k>len(intersect_dict):
        raise ValueError("k is greater than length of intersect_dict")
    return [contract_name for contract_name in intersect_dict.keys() if intersect_dict[contract_name] > k]

# %% ../nbs/covalent_api.ipynb 30
def holders_more_than_k_addresses(portfolios: list[dict], contract_addresses: list[str], k: int) -> list[dict]:
    """
    Given a list of portfolios, get the holders that hold more than k of the given addresses.
    Inputs:
        portfolios: list of portfolio (dicts)
        contract_addresses: list of contract addresses
        k: minimum number of contract_addresses a holder should have
    Output:
        list[dict]: list of holders that hold more than k of the given addresses.
    """
    lst = []
    for _holder in portfolios:
        holder_addresses = set(_token['contract_address'] for _token in _holder['portfolio'])
        if len(holder_addresses.intersection(contract_addresses)) > k:
            lst.append(_holder)
    return lst

# %% ../nbs/covalent_api.ipynb 33
def strip_none(portfolios:List[dict])->List[dict]:
    """Strip the holdings that have no quote
        Inputs: 
            portfolios: list of `portfolio` dictionaries
        Outputs:
            portfolios: list of `portfolio` dictionaries with no `None` quotes
    """

    for portfolio in portfolios:

        stripped_portfolio=[]
        for _holding in portfolio['portfolio']:
            if _holding['quote'] != None:
                stripped_portfolio.append(_holding)
        portfolio['portfolio'] = stripped_portfolio

    return portfolios


def strip_dust(portfolios:List[dict])->List[dict]:
    """Strip the holdings that are small
        Inputs: 
            portfolios: list of `portfolio` dictionaries
        Outputs:
            portfolios: list of `portfolio` dictionaries with no `None` quotes
    """
    for portfolio in portfolios:

        stripped_portfolio=[]
        for _holding in portfolio['portfolio']:
            if float(_holding['quote']) >= 1.0: #somewhat arbitrary, we choose $1USD. can also do _holding['type'] ~= 'dust'. something to keep in mind
                stripped_portfolio.append(_holding)
        portfolio['portfolio'] = stripped_portfolio

    return portfolios

# %% ../nbs/covalent_api.ipynb 37
class WalletListToIntersectDict:
    #TODO: needs a better name perhaps?
    """Wrapper to compute the `intersect_dict` given a list of wallets. Basically a map to the `intersect_dict` (and intermediate data) 
        for a given list of wallets.) Note that intermediate data (e.g. `portfolios`) is also stored and often useful.)      
        Inputs:
            cov_api: Covalent_Api instance
            wallet_list: list of wallets, of the form [{'address':wallet_1},{'address':wallet_2}]
            chainName: e.g. 'eth-mainnet'
            date: e.g. '2023-09-24'
            quote_currency: e.g. USD
    """

    def __init__(self, cov_api, wallet_list, chainName,date,quote_currency="USD"): 
        store_attr()
        self.intersect_dict = self.get_data()
        
    def get_data(self):
        self.portfolios = self.cov_api.get_holders_portfolios(wallet_list=self.wallet_list,chainName=self.chainName,date=self.date)
        self.portfolios = strip_none(self.portfolios)
        self.portfolios = strip_dust(self.portfolios)
        self.union_portfolios  = Union_Portfolios(self.portfolios)#i.e. all the tokens ("union")
        self.intersect_dict = intersection_count(self.portfolios,self.union_portfolios)

        return self.intersect_dict

# %% ../nbs/covalent_api.ipynb 42
class AddressTopnToIntersectDict(WalletListToIntersectDict):
    """Wrapper to compute the `intersect_dict` for a given tokenAddress, chainName, date, and n. 
        In other words, this class is a wrapper to compute the intersection of the top n holders
        of a token on a given date. First compute the top n holders, then pass the functionality
        off to the parent class.
        Comment: The top n holders are current, the date is historical. So, it will compute the historical portfolios (on the given date) of the current top n holders.
       
       Inputs:
            `cov_api`: an instance of the Covalent_Api class
            `tokenAddress`: the token address of the token we want to compute the `intersect_dict` for. e.g. '0x72e4f9F808C49A2a61dE9C5896298920Dc4EEEa9' (hpbitcoin)
            `tokenName`: e.g. HarryPotterObamaSonic10Inu
            `chainName`: e.g. 'eth-mainnet'
            `date`: e.g. '2023-08-30'
            `n`: the number of holders we want to compute the `intersect_dict` for
            `quote_currency`: e.g. 'USD'
    
    """

    def __init__(self, cov_api, tokenAddress,tokenName, chainName,date,n,quote_currency="USD"): 
        store_attr()
        assert n <= 100, f"The value of n should be <= 100. The current value is {n}."
        self.token_holders = self.cov_api.get_token_holders(chainName=self.chainName, tokenAddress=self.tokenAddress, page_size=100, page_number=0)
        self.top_n_holders = self.token_holders[0:n] #the top n holders of the token, which will be `wallet_list` in the parent class

        super().__init__(cov_api=cov_api,wallet_list=self.top_n_holders, chainName=chainName, date=date, quote_currency=quote_currency)
        


# %% ../nbs/covalent_api.ipynb 46
def print_tokens_in_portfolios(token_list, portfolios):
    """Prints the values of each token in `token_list` in each portfolio in `portfolios`.
    
    Args:
    token_list: A list of tokens.
    portfolios: A list of portfolio dictionaries.
    """
    print("Calculating and Printing Values in Each Portfolio for the Following Tokens:")
    token_table = PrettyTable(field_names=["Token Name", "Contract Address"])
    for token in token_list:
        token_table.add_row([token[0], token[1]])
    print(token_table)
    print("\nNow Printing the Coin Values for each Portfolio...\n")
    
    for portfolio in portfolios:
        print(f"Portfolio: {portfolio['address']}\n")
        
        portfolio_table = PrettyTable(field_names=["Token", "Quote ($)", "Percentage of Portfolio (%)"])
        token_values = {}
        portfolio_sum = portfolio.get('portfolio_sum', 1) or 1  # avoid division by zero
        
        token_address_to_token = {token[1]: token for token in token_list}
        
        for holding in portfolio.get('portfolio', []):
            token = token_address_to_token.get(holding['contract_address'])
            if token:
                quote = holding.get('quote', 0)
                token_values[token] = quote
                portfolio_table.add_row([token[0], f"${quote:.2f}", f"{quote / portfolio_sum * 100:.2f}"])
        print(portfolio_table)
        print("\n" + "="*80 + "\n")


# %% ../nbs/covalent_api.ipynb 50
def portfolio_to_pie_chart(token_list, portfolio):
    labels = []
    sizes = []
    portfolio_sum = portfolio.get('portfolio_sum', 0) or 1
    
    token_address_to_token = {token[1]: token for token in token_list}
    other_sum = portfolio_sum
    
    for holding in portfolio.get('portfolio', []):
        token = token_address_to_token.get(holding['contract_address'])
        if token:
            quote = holding.get('quote', 0)
            labels.append(f"{token[0]} ({quote / portfolio_sum * 100:.2f}%)")
            sizes.append(quote)
            other_sum -= quote
    
    if other_sum > 0:
        labels.append(f"Other ({other_sum / portfolio_sum * 100:.2f}%)")
        sizes.append(other_sum)
    
    fig1, ax1 = plt.subplots(figsize=(8,6))
    ax1.pie(sizes, startangle=90)
    ax1.legend(labels, title=f"Tokens", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))
    ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
    
    plt.show()


# %% ../nbs/covalent_api.ipynb 54
def print_portfolios_more_than_k(obj:object, k:int=2):
    portfolios = obj.portfolios
    intersect_dict = obj.intersect_dict
    n = len(portfolios)
    date = obj.date
    
    token_list = contract_name_if_more_than_k_holders(intersect_dict=intersect_dict, k=k)
    
    formatted_token_list = '\n\t'.join([f"{name}: {address}" for name, address in token_list])
    
    if hasattr(obj, 'top_n_holders'):
        tokenName = obj.tokenName
        test_eq(obj.n, n)  # I am assuming you have a method to compare obj.n and n.
        print(f"The tokens where, for each token, more than {k} out of the top {n} holders of {tokenName} hold them as of {date} are:\n\t{formatted_token_list}\n")
    else:
        print(f"The tokens where, for each token, more than {k} out of the {n} portfolios hold them as of {date} are:\n\t{formatted_token_list}\n")
    
    for token in token_list:
        print(f"Printing the portfolios that hold {token}:\n")
        _portfolios = [portfolio for portfolio in portfolios if token[1] in [holding['contract_address'] for holding in portfolio['portfolio']]]
        
        # # If you want to print tokens in portfolios
        # print_tokens_in_portfolios([token], _portfolios)
        
        # If you want to plot pie chart for each portfolio
        for portfolio in _portfolios:
            print(f"Portfolio: {portfolio['address']} has total value ${portfolio['portfolio_sum']:.0f} USD \n")
            portfolio_to_pie_chart(token_list, portfolio)
            #print_tokens_in_portfolios(token_list,portfolios=[portfolio])
            

# k=4
# print_portfolios_more_than_k(hpbitcoin_holder_data,k=k)
