# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/zerion_api.ipynb.

# %% auto 0
__all__ = ['ZERION_AUTH', 'get_portfolio_value', 'get_wallet_positions', 'get_chart', 'unix_timestamp_to_date',
           'timestamp_price_pairs_to_date_dict', 'timestamp_price_pairs_to_date',
           'timestamp_price_pairs_to_avg_date_dict']

# %% ../nbs/zerion_api.ipynb 3
import json
import requests
import os
from dotenv import load_dotenv
load_dotenv()

ZERION_AUTH = os.environ.get('zerion_auth')

# %% ../nbs/zerion_api.ipynb 5
def get_portfolio_value(address:str):
    """Get the total value of a portfolio in USD"""
    #TODO: Obviously need to complete docstring etc, but we can leave as vague for now; unclear if we will
    #e.g. wrap in class etc.

    #API docs: https://developers.zerion.io/reference/getwalletportfolio

    #COMMENT: note that the docs have some nice info about different responses, e.g. 202 etc. This may be useful later on.

    url = f"https://api.zerion.io/v1/wallets/{address}/portfolio?currency=usd"

    headers = {
        "accept": "application/json",
        "authorization": ZERION_AUTH
    }

    response = requests.get(url, headers=headers)

    return response.json()

if __name__ == '__main__':
    _dict = get_portfolio_value(_address)
    print(f"Portfolio value according to zerion is: {_dict['data']['attributes']['positions_distribution_by_type']['wallet']}")


# %% ../nbs/zerion_api.ipynb 9
def get_wallet_positions(address:str, 
                         position_types:list[str]=None,
                         protocol_ids:list[str]=None,
                         fungible_ids:list[str]=None,
                         currency:str='usd'):
    """This endpoint returns a list of wallet positions.
    
        API docs: https://developers.zerion.io/reference/listwalletpositions
    """ 

    position_types_str = ''
    protocol_ids_str = ''
    fungible_ids_str = ''
    
    if position_types:
        position_types_str = f"filter[position_types]={','.join(position_types)}&"
    if protocol_ids:
        protocol_ids_str = f"filter[protocol_ids]={','.join(protocol_ids)}&"
    if fungible_ids:
        fungible_ids_str = f"filter[fungible_ids]={','.join(fungible_ids)}&"

    url = f"https://api.zerion.io/v1/wallets/{address}/positions/?currency={currency}&{position_types_str}{protocol_ids_str}{fungible_ids_str}filter[trash]=only_non_trash&sort=value"

  

    headers = {
        "accept": "application/json",
        "authorization": ZERION_AUTH
              }

    response = requests.get(url, headers=headers)


    return response.json() 

#This is mostly to help prototyping below, perhaps we will put its own cell explaining "how to use" eventually
if __name__ == '__main__':

    _dict = get_wallet_positions(_address)
    _portfolio = [_dict['data'][i]['attributes'] for i in range(len(_dict['data']))]
    print(f"First item in portfolio is: {_portfolio[0]}")
    print('Note that there is other information in the _dict object:\n')
    for k,v in _dict['data'][0].items():
        print(f"\tKey type is: {type(k)}, Value type is: {type(v)}")
        print(f"\tKey: {k}, Value: {v}\n")



# %% ../nbs/zerion_api.ipynb 14
def get_chart(address:str,period:str='max',currency:str='usd'):
    """The 'charts' endpoint in the Zerion API allows users to retrieve a chart for a specific fungible asset.
        `period` may be any of: 'max','hour', 'day', 'week', 'month', 'year'.
    
    """

    url = f"https://api.zerion.io/v1/fungibles/{address}/charts/{period}?currency={currency}"

    headers = {
        "accept": "application/json",
        "authorization": ZERION_AUTH
              }


    response = requests.get(url, headers=headers)
    return response.json()



# %% ../nbs/zerion_api.ipynb 22
import datetime
from collections import defaultdict

def unix_timestamp_to_date(unix_timestamp):
    return datetime.datetime.utcfromtimestamp(unix_timestamp).strftime('%Y/%m/%d')

def timestamp_price_pairs_to_date_dict(points:list)->dict:
    """Inputs:
            points: list of lists (pairs) where first coord is unix timestamp, second is price on that date.
                    e.g. [1683788578, 0.00010605266543295529] 
       Outputs:
                    dict where key is date string and value is price on that date.
       Comment:
                    The source code is basically self explanatory.      
    """

    return {unix_timestamp_to_date(point[0]): point[1] for point in points}

def timestamp_price_pairs_to_date(points:list)->list:
    """Inputs:
            points: list of lists (pairs) where first coord is unix timestamp, second is price on that date.
                    e.g. [1683788578, 0.00010605266543295529] 
       Outputs:
                    list of lists (pairs) where first coord is date string, second is price on that date.
                    e.g. ['2023/05/11', 0.00010605266543295529] 
       Comment:
                    The source code is basically self explanatory.      
    """

    return [[unix_timestamp_to_date(point[0]), point[1]] for point in points]

def timestamp_price_pairs_to_avg_date_dict(points: list) -> dict:
    """Inputs:
            points: list of lists (pairs) where first coord is unix timestamp, second is price on that date.
                    e.g. [1683788578, 0.00010605266543295529] 
       Outputs:
                    dict where key is the date string and value is the average price for that date.
        
    """
    
    date_price_aggregator = defaultdict(lambda: {'sum': 0, 'count': 0})

    for point in points:
        date = unix_timestamp_to_date(point[0])
        date_price_aggregator[date]['sum'] += point[1]
        date_price_aggregator[date]['count'] += 1

    return {date: data['sum']/data['count'] for date, data in date_price_aggregator.items()}


