# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/covalent_api_prototyping.ipynb.

# %% auto 0
__all__ = ['logger', 'COVALENT_API_KEY', 'url_decorator', 'Covalent_Api']

# %% ../nbs/covalent_api_prototyping.ipynb 5
import json
import requests
from requests.auth import HTTPBasicAuth
from requests.exceptions import HTTPError, RequestException
import time
from fastcore.basics import *
from fastcore.test import *
from typing import List

# %% ../nbs/covalent_api_prototyping.ipynb 6
import logging

# Set up basic logging configuration
logging.basicConfig(level=logging.INFO, format='%(message)s')

logger = logging.getLogger(__name__)

# %% ../nbs/covalent_api_prototyping.ipynb 7
import os
from dotenv import load_dotenv

load_dotenv()
COVALENT_API_KEY = os.environ.get('covalent_api_key')

# %% ../nbs/covalent_api_prototyping.ipynb 20
#The general API is: 
#                       def some_function(self,args):
#                            url = ... #define the url 
#                            return self.get_items(url)

#rather than writing self.get_items(url) every time, we can use a decorator to do this for us.
from requests.exceptions import HTTPError, ReadTimeout, RequestException

def url_decorator(func):
    def wrapper(self, *args, **kwargs):
        url = func(self, *args, **kwargs)
        return self.get_items(url)
    return wrapper

class Covalent_Api:
    """This class is used to interact with the Covalent API.
    """

    def __init__(self, covalent_api_key=COVALENT_API_KEY,
                 request_timeout=30,retries=5,delay=1
                 ):
        self.covalent_api_key = covalent_api_key
        self.request_timeout = request_timeout
        self.retries = retries
        self.delay = delay

    def get_items(self, url):
        """Given a url, get the items from the API."""

        headers = {"accept": "application/json"}
        basic = HTTPBasicAuth(f'{self.covalent_api_key}', '')

        while self.retries > 0:
            try:
                response = requests.get(url, headers=headers, auth=basic, timeout=self.request_timeout)
                response.raise_for_status()  
                data = response.json()['data']  # Directly access 'data' field
                
                if data is None:
                    logger.warning(f"No data received from {url}. Retries left: {self.retries}")
                    self.retries -= 1
                    time.sleep(self.delay)
                    continue

                if isinstance(data, list):
                    return data

                return data.get('items')

            except (ReadTimeout, RequestException, HTTPError) as e:
                logger.warning(f"{type(e).__name__} occurred: {e} for URL: {url}. Retrying in {self.delay} seconds...")
                self.retries -= 1
                time.sleep(self.delay)
                continue
            except Exception as e:
                logger.error(f"Unexpected error: {e} for URL: {url}. Returning None.")
                return None

        logger.warning(f"Exceeded the maximum number of retries ({self.retries}) for URL: {url} without success")
        return None

    @url_decorator
    def _fetch_historical_balances(self, chainName: str, walletAddress: str, date: str, quote_currency="USD") -> str:
        """
        This is an internal method that just constructs and returns the URL.
        """
        assert type(date) is str, "date must be a string"
        url = f"https://api.covalenthq.com/v1/{chainName}/address/{walletAddress}/historical_balances/?quote-currency={quote_currency}&date={date}"
        return url 

    def get_historical_balances(self, chainName: str, walletAddress: str, date: str, quote_currency="USD") -> list[dict]:
        """
        Given a wallet address, get the historical balances for that wallet address on the specified chain and date.
        This method fetches the data and then processes it.
        """
        items = self._fetch_historical_balances(chainName, walletAddress, date, quote_currency)
        if items is None:
            logger.error(f"Failed to fetch data for {walletAddress} on date {date}")
            return []
        
        return items 
    
    @url_decorator
    def get_token_holders(self, chainName: str, tokenAddress: str, block_height=None, page_size=100, page_number=None) -> list:
        """
        API docs: https://www.covalenthq.com/docs/api/balances/get-token-holders-as-of-any-block-height-v2/
        Fetches the token holders for a specific token on a given chain.
        Note: There is a possible `block-height` parameter, which we omit for now (see the API docs to clarify)
        
        Inputs:
            `chainName`: The chain name e.g. 'eth-mainnet'.
            `tokenAddress`: The token's address.
            `block_height`: Ending block to define a block range.
            `page_size`: Number of items per page. Supported values are 100 and 1000.
            `page_number`: 0-indexed page number to begin pagination.
        Outputs:
            `items`, a list of dictionaries, each dictionary containing information about a token holder.

        Note: This gets the holders by percentage (i.e. largest holdest to smallest)

        Note:
        While the core function generates a URL, the applied @url_decorator 
        modifies the return behavior to fetch items using that URL.
        """

        base_url = f"https://api.covalenthq.com/v1/{chainName}/tokens/{tokenAddress}/token_holders_v2/?"

        
        if block_height is not None:
            base_url += f"&block-height={block_height}"
        if page_size is not None:
            base_url += f"&page-size={page_size}"
        if page_number is not None:
            base_url += f"&page-number={page_number}"

        return base_url

    def get_holders_portfolios(self,wallet_list:List[dict],chainName:str,date:str,quote_currency="USD",log_output=False)->List[dict]:
        """Input: 
                `wallet_list`: a list of  wallets as dicts. Each dict must contain the key 'address'.
                 See get_historical_balances for description of other inputs.
           Output: `wallet_list` - the same list of dictionaries with the portfolio added.
        """

        #TODO: this address 0x80f8c8d0d29c99b7af1b4d97cad357061037ecb3 seems to give false data (~$20m for ShibaDoge
        #Maybe should email covalent about this to let them know. Please see the dextools chart for shibadoge. 
        #We plonked the info manually into the covalent API to verify and it looks like it is an issue on their end.
        #Just something to be aware of: covalent seems to not be infallible.

        # Setting up logging level based on the log_output value
        if log_output:
            logger.setLevel(logging.INFO)
        else:
            logger.setLevel(logging.WARNING)

        #loop over the list of dictionaries (holders of the token)
        for _holder in wallet_list: #this loop should be parallelized, but ok for now provided it isn't too big.

            _address = _holder['address']
            logger.info(f'getting {_address} portfolio')  # Logging statement in place of print
            _items = self.get_historical_balances(chainName=chainName,walletAddress=_address, quote_currency=quote_currency, date=date)
            if _items == None:
                print(f'failed to get {_address} portfolio: `get_historical_balances` returned `None`')  # Logging statement in place of print
                _holder['portfolio']=None
                _holder['portfolio_sum']=None
                continue

            #TODO: Make this more efficient: possibly convert to numpy array or dataframe or something and then sum
            
            none_to_zero = lambda x: 0 if x is None else x
            portfolio_sum = sum([none_to_zero(holding['quote']) for holding in _items])
            
            _holder['portfolio']=_items #update the _holder with the whole portfolio
            _holder['portfolio_sum']=portfolio_sum #update the _holder with the total value of the portfolio

            logger.info(f'got {_address} portfolio')  # Logging statement in place of print
            
        return wallet_list
    
